# Vue3 组件库设计规范

本规范旨在定义 Vue3 组件库的设计、开发、维护标准，确保组件库具备 **一致性、可维护性、可扩展性、良好的开发体验**，同时满足业务复用与生态适配需求（如支持 SSR、主题定制、TypeScript 强类型）。

## 一、核心设计原则

组件库设计需遵循以下 5 大原则，贯穿从需求定义到落地的全流程：

1. **单一职责原则**：一个组件只聚焦一个核心功能（如 `Button` 负责按钮交互，不包含表单验证逻辑），避免过度封装导致臃肿。
2. **一致性原则**：组件的命名、API、交互、样式保持统一（如所有触发“确认”的按钮统一用 `@confirm` 事件，而非 `@ok`/`@submit` 混用）。
3. **可扩展性原则**：预留扩展入口（如插槽、自定义类名、暴露内部方法），支持用户在不修改源码的前提下定制功能。
4. **无侵入性原则**：组件不强制依赖外部环境（如不绑定特定路由库、状态管理库），仅通过 Props/Events 与外部通信。
5. **可访问性原则（A11y）**：符合 W3C 可访问性标准，支持键盘导航、屏幕阅读器，确保不同用户群体（如视障用户）可正常使用。

## 二、目录结构规范

采用 Monorepo 架构（基于 pnpm workspace），目录结构需清晰区分“组件核心代码”“工具层”“文档”“测试”，便于维护与扩展：

```
lm-web/
├── packages/
│   ├── components/       # 组件核心目录（按组件拆分）
│   │   ├── src/
│   │   │   ├── button/   # 单个组件目录（PascalCase 组件名对应 kebab-case 目录）
│   │   │   │   ├── Button.vue       # 组件模板/逻辑
│   │   │   │   ├── button.ts        # Props/Events 类型定义
│   │   │   │   ├── button.css       # 组件样式（或 CSS Modules）
│   │   │   │   └── index.ts         # 组件导出
│   │   │   ├── date-picker/    # 多单词组件目录（kebab-case）
│   │   │   │   ├── DatePicker.vue   # 多单词组件文件（PascalCase）
│   │   │   │   ├── date-picker.ts
│   │   │   │   └── index.ts
│   │   │   └── index.ts  # 所有组件聚合导出（供外部引入）
│   │   ├── types/        # 全局类型定义（如组件实例类型、通用类型）
│   │   ├── utils/        # 组件共享工具函数（如 DOM 操作、格式转换）
│   │   └── styles/       # 全局样式（主题变量、重置样式、基础工具类）
│   ├── theme/            # 主题包（可选，支持多主题切换）
│   │   ├── src/
│   │   │   ├── variables.css  # 主题变量（颜色、字体、间距等）
│   │   │   └── index.css      # 主题入口
│   └── docs/             # 组件文档（用 VuePress/Storybook 实现）
├── turbo.json            # 构建任务配置（如增量构建、并行任务）
├── vite.config.ts        # 组件库打包配置（Vite 库模式）
└── package.json          # 根目录依赖与脚本
```

## 三、组件实现规范

### 1. 命名规范

#### （1）组件命名

- 采用 **PascalCase 大驼峰命名**（符合 Vue 官方推荐，且与 HTML 标签区分），如 `Button`、`Input`、`Select`。
- 组件目录名与组件名保持对应：**单单词组件**目录用小写（如 `button/` 对应 `Button.vue`）；**多单词组件**目录用 kebab-case（短横线连接，如 `date-picker/` 对应 `DatePicker.vue`），避免文件系统大小写敏感问题。
- 避免与 HTML 原生标签重名（如不命名为 `Div`、`Span`），如需基础容器组件，可加前缀（如 `BaseContainer`）。

##### 多单词组件命名特殊规则

当组件名由多个单词组成时，需遵循“语义优先、结构清晰”原则，确保“见名知意”：

1. **语义化拆分，拒绝无意义缩写**：按功能逻辑拆分单词，不使用行业非通用缩写（通用缩写如 `URL`、`ID` 可保留）。
   - 正确：`DatePicker`（日期选择器，`Date`+`Picker`）、`InputNumber`（数字输入框，`Input`+`Number`）、`ModalHeader`（模态框头部，`Modal`+`Header`）
   - 错误：`DtPk`（缩写模糊）、`InpNum`（可读性差）
2. **避免冗余词汇**：不堆砌“Component”“Widget”等无意义后缀，聚焦核心功能。
   - 正确：`TableColumn`（表格列）、`SelectOption`（下拉选项）
   - 错误：`TableColumnComponent`（冗余“Component”）
3. **复合功能按“主次排序”**：若组件是“主功能+子功能”组合（如“表单+验证”“弹窗+确认”），主功能在前，子功能在后，明确从属关系。
   - 正确：`FormValidator`（表单验证，主功能`Form`+子功能`Validator`）、`ModalConfirm`（确认弹窗，主功能`Modal`+子功能`Confirm`）
   - 错误：`ValidatorForm`（颠倒主次，易误解为“验证器的表单”）

##### 组合组件命名（主组件+子组件）

若组件存在“主-子”层级关系（如下拉选择器包含选项、表格包含列），子组件名需包含主组件名，明确归属：

- 主组件：`Select`（下拉选择器）、`Table`（表格）
- 子组件：`SelectOption`（下拉选项）、`SelectGroup`（下拉分组）、`TableColumn`（表格列）、`TableHeader`（表格头部）
- 使用示例：
  ```vue
  <template>
    <Select v-model="value">
      <SelectGroup label="基础选项">
        <SelectOption value="1">选项1</SelectOption>
        <SelectOption value="2">选项2</SelectOption>
      </SelectGroup>
    </Select>
  </template>
  ```

#### （2）Props 命名

- 采用 **camelCase 小驼峰命名**（符合 JavaScript 变量规范），如 `isDisabled`、`maxLength`。
- 传递给组件时，模板中可自动转换为 kebab-case（Vue 特性），用户使用时两种格式均可（推荐 kebab-case 更符合 HTML 习惯）：
  ```vue
  <!-- 正确：模板中可用 kebab-case -->
  <DatePicker is-range />
  <!-- 正确：也可用 camelCase（不推荐，建议统一 kebab-case） -->
  <DatePicker isRange />
  ```

#### （3）Events 命名

- 采用 **kebab-case 短横线命名**（符合 HTML 事件规范），如 `update:model-value`、`change`、`confirm`。
- 事件名需语义化，避免模糊命名（如不用 `onClick`，而用 `confirm`/`cancel` 明确意图）。
- 支持双向绑定的组件，需遵循 Vue 语法糖 `v-model`，事件名固定为 `update:model-value`：

  ```vue
  <!-- 组件内部触发双向绑定更新 -->
  <script setup>
    const emit = defineEmits(['update:model-value']);
    emit('update:model-value', newValue);
  </script>

  <!-- 用户使用时 -->
  <DatePicker v-model="date" />
  ```

#### （4）插槽（Slots）命名

- 默认插槽无需命名，直接用 `<slot>`。
- 具名插槽采用 **kebab-case 命名**，如 `header`、`footer`、`empty`（空状态插槽）。
- 插槽需添加文档说明，明确用途（如 `empty` 插槽用于自定义空数据展示）：

  ```vue
  <!-- 组件内部（DatePicker.vue） -->
  <div class="date-picker">
    <slot name="header">日期选择器标题</slot>
    <slot name="empty">暂无可选日期</slot>
    <slot></slot> <!-- 默认插槽：日期选择面板 -->
  </div>

  <!-- 用户使用时 -->
  <DatePicker>
    <template #header>自定义选择日期</template>
    <template #empty>当前月份无数据</template>
  </DatePicker>
  ```

### 2. Props 设计规范

#### （1）类型与默认值

- 所有 Props 必须显式声明类型（TypeScript），避免 `any`。
- 必填 Props 需标记 `required: true`，并提供清晰的错误提示（通过 `validator`）。
- 复杂类型（如对象、数组）的默认值需用函数返回（避免引用类型共享）：

  ```typescript
  // date-picker.ts（多单词组件 Props 类型）
  import { SizeType } from '../../types'
  export interface DatePickerProps {
    // 基础类型 + 默认值
    size?: SizeType
    isRange?: boolean // 是否为范围选择（多单词 Props 用 camelCase）
    placeholder?: string
    // 复杂类型 + 函数返回默认值
    disabledDate?: (date: Date) => boolean
    // 必填项 + 验证
    modelValue: Date | [Date, Date] // 范围选择时为数组
  }

  // DatePicker.vue 中使用
  <script setup lang="ts">
  import { DatePickerProps } from './date-picker'
  const props = withDefaults(defineProps<DatePickerProps>(), {
    size: 'medium',
    isRange: false,
    placeholder: '请选择日期',
    disabledDate: () => false // 复杂类型默认值用函数
  })

  // 可选：添加自定义验证
  const propsWithValidator = defineProps({
    modelValue: {
      type: [Date, Array] as PropType<Date | [Date, Date]>,
      required: true,
      validator: (val: Date | [Date, Date]) => {
        if (Array.isArray(val) && val.length !== 2) {
          console.error('范围选择时，modelValue 需为长度 2 的 Date 数组')
          return false
        }
        return true
      }
    }
  })
  </script>
  ```

#### （2）Props 精简原则

- 避免冗余 Props：如已支持 `class`/`style` 透传，无需额外定义 `customClass`/`customStyle`（Vue 会自动透传非 Props 属性到根元素）。
- 拆分复杂 Props：如组件需要多个配置项，可将其合并为一个对象类型 Props，避免 Props 数量过多：

  ```typescript
  // 不推荐：Props 数量过多
  interface BadDatePickerProps {
    startPlaceholder: string;
    endPlaceholder: string;
    startDisabled: boolean;
    endDisabled: boolean;
  }

  // 推荐：合并为对象类型
  interface GoodDatePickerProps {
    rangeConfig?: {
      startPlaceholder: string;
      endPlaceholder: string;
      startDisabled: boolean;
      endDisabled: boolean;
    };
  }
  ```

### 3. 样式规范

#### （1）样式隔离

- 优先使用 **Scoped CSS**（通过 `style scoped`）避免样式污染，如需修改子组件样式，可使用 `::v-deep`（Vue3 推荐写法）：

  ```vue
  <style scoped>
    /* 样式隔离：仅作用于当前组件 */
    .date-picker {
      width: 100%;
    }

    /* 修改子组件样式：::v-deep + 子组件选择器 */
    ::v-deep .calendar-panel {
      border-radius: 4px;
    }
  </style>
  ```

- 复杂组件（如 `DatePicker` 包含日历面板）可使用 **CSS Modules**（通过 `style module`），避免类名冲突：

  ```vue
  <style module>
    .picker {
      position: relative;
    }
    .panel {
      position: absolute;
      top: 100%;
    }
  </style>

  <template>
    <div :class="$style.picker">
      <div :class="$style.panel"></div>
    </div>
  </template>
  ```

#### （2）主题与 Token 设计

- 采用 **CSS 变量（Custom Properties）** 定义全局主题 Token，确保样式一致性且支持动态切换：

  ```css
  /* styles/variables.css（全局主题变量） */
  :root {
    /* 颜色 Token */
    --color-primary: #42b983;
    --color-success: #52c41a;
    --color-warning: #faad14;
    /* 字体 Token */
    --font-size-sm: 12px;
    --font-size-md: 14px;
    /* 间距 Token */
    --spacing-xs: 4px;
    --spacing-sm: 8px;
  }

  /* 组件样式中使用 Token（DatePicker.vue） */
  <style scoped>
  .date-picker {
    font-size: var(--font-size-md);
    color: var(--color-text-primary);
  }
  .date-picker-input {
    padding: var(--spacing-sm) var(--spacing-xs);
    border: 1px solid var(--color-border);
  }
  </style>
  ```

- 支持主题定制：用户可通过覆盖 CSS 变量修改主题（无需修改组件库源码）：
  ```css
  /* 用户项目中覆盖主题 */
  :root {
    --color-primary: #1890ff; /* 自定义主色为蓝色 */
  }
  ```

#### （3）响应式样式

- 优先使用 **CSS 媒体查询** 实现响应式，避免依赖 JavaScript 监听窗口变化（性能更优）：

  ```css
  .date-picker {
    width: 100%;
  }

  @media (min-width: 768px) {
    .date-picker {
      width: 300px;
    }
  }

  @media (min-width: 1200px) {
    .date-picker {
      width: 400px;
    }
  }
  ```

- 如需组件内部响应式逻辑（如根据窗口宽度调整行为），使用 Vue3 的 `useWindowSize` 等 Composition API，避免直接操作 `window`。

### 4. 逻辑实现规范

#### （1）Composition API 优先

- 组件逻辑必须使用 **Vue3 Composition API**（`script setup` 语法糖），避免 Options API（不利于逻辑复用与 TypeScript 集成）。
- 复杂逻辑需拆分到独立的 Composable 函数（如 `useDateRange.ts`、`useCalendar.ts`），提高可维护性：

  ```typescript
  // composables/useDateRange.ts（多单词组件独立逻辑）
  import { ref, watch, type Ref } from 'vue'

  export function useDateRange(initialRange: [Date, Date] = [new Date(), new Date()]) {
    const range: Ref<[Date, Date]> = ref(initialRange)
    const isInvalid = ref(false)

    // 验证日期范围有效性（开始日期 <= 结束日期）
    watch(range, ([start, end]) => {
      isInvalid.value = start > end
    }, { deep: true })

    // 重置日期范围
    const resetRange = () => {
      range.value = [new Date(), new Date()]
    }

    return { range, isInvalid, resetRange }
  }

  // DatePicker.vue 中使用（范围选择逻辑）
  <script setup lang="ts">
  import { useDateRange } from '../../composables/useDateRange'
  const { range, isInvalid, resetRange } = useDateRange()
  </script>
  ```

#### （2）避免副作用与外部依赖

- 组件内部不直接操作全局状态（如 `window`、`document`），如需操作 DOM，使用 `ref` 或 `useTemplateRefsList`（Vue3 推荐），避免 `document.querySelector`：

  ```vue
  <!-- 正确：使用 ref 操作 DOM（DatePicker.vue） -->
  <template>
    <input ref="inputRef" type="text" class="date-picker-input" />
  </template>

  <script setup lang="ts">
    import { ref, onMounted } from 'vue';
    const inputRef = ref<HTMLInputElement>(null);

    onMounted(() => {
      if (inputRef.value) {
        inputRef.value.focus(); // 自动聚焦输入框
      }
    });
  </script>
  ```

- 不依赖外部库（如 `lodash`），如需工具函数，内置到组件库的 `utils` 目录（避免增加用户依赖体积）。

#### （3）性能优化

- 避免在 `setup` 或模板中执行 heavy 计算，使用 `computed` 缓存计算结果：

  ```vue
  <script setup lang="ts">
    import { ref, computed } from 'vue';
    const dateList = ref<Date[]>([]);

    // 推荐：computed 缓存过滤结果（多单词组件场景）
    const validDateList = computed(() => {
      return dateList.value.filter(date => date >= new Date());
    });

    // 不推荐：每次渲染都会重新计算
    const badValidDateList = () => {
      return dateList.value.filter(date => date >= new Date());
    };
  </script>
  ```

- 大型列表组件（如 `Table`、`Select`）需支持虚拟滚动（如集成 `vue-virtual-scroller`），避免渲染过多 DOM 导致性能问题。
- 使用 `shallowRef`/`markRaw` 处理不需要响应式的数据（如大型配置对象、第三方库实例），减少 Vue 响应式追踪开销：

  ```typescript
  import { shallowRef, markRaw } from 'vue';
  import { SomeHeavyCalendarLib } from 'some-library';

  // 不需要响应式的第三方实例，用 markRaw 标记
  const calendarInstance = markRaw(new SomeHeavyCalendarLib());
  // 仅需追踪顶层引用的对象，用 shallowRef
  const calendarConfig = shallowRef({
    showToday: true,
    disabledDays: [0, 6], // 周末禁用（内部属性变化不追踪）
  });
  ```

## 四、TypeScript 规范

### 1. 类型定义

- 组件 Props、Events、Slots、暴露方法需显式定义类型，放在组件目录下的 `xxx.ts` 文件（如 `date-picker.ts`），便于复用与维护。
- 全局通用类型（如 `SizeType`、`ValueType`）放在 `packages/components/types/` 目录，统一导出：

  ```typescript
  // types/index.ts（全局通用类型）
  export type SizeType = 'small' | 'medium' | 'large';
  export type StatusType = 'success' | 'warning' | 'error' | 'info';

  // date-picker.ts（多单词组件类型）
  import { SizeType } from '../../types';
  export interface DatePickerProps {
    size?: SizeType;
    isRange?: boolean;
    modelValue: Date | [Date, Date];
    disabledDate?: (date: Date) => boolean;
  }

  // 暴露组件实例类型（供用户通过 ref 获取）
  export interface DatePickerInstance {
    focus: () => void; // 组件暴露的方法：输入框聚焦
    reset: () => void; // 组件暴露的方法：重置日期
  }
  ```

### 2. 类型导出

- 组件库需生成 **类型声明文件（.d.ts）**，确保用户在使用时能获得完整的类型提示。
- 通过 Vite 配置自动生成类型声明（需安装 `vue-tsc`）：

  ```typescript
  // vite.config.ts
  import { defineConfig } from 'vite';
  import vue from '@vitejs/plugin-vue';
  import vueJsx from '@vitejs/plugin-vue-jsx';

  export default defineConfig({
    plugins: [vue(), vueJsx()],
    build: {
      lib: {
        entry: 'packages/components/src/index.ts',
        name: 'MyComponentLibrary',
        fileName: format => `my-component-library.${format}.js`,
      },
      rollupOptions: {
        external: ['vue'],
        output: {
          globals: { vue: 'Vue' },
        },
      },
    },
    // 生成类型声明
    plugins: [
      // 其他插件...
      {
        name: 'generate-dts',
        async closeBundle() {
          const { execSync } = require('child_process');
          execSync('vue-tsc --declaration --emitDeclarationOnly --outDir dist/types', {
            stdio: 'inherit',
          });
        },
      },
    ],
  });
  ```

## 五、文档与测试规范

### 1. 文档规范

- 每个组件需包含 **完整文档**，内容包括：
  1. 组件介绍：核心功能与使用场景（多单词组件需说明“功能拆分逻辑”，如 `DatePicker` 说明“支持单日期/范围选择”）；
  2. 基础示例：最简单的使用代码（多单词组件需覆盖核心场景，如 `DatePicker` 同时提供“单日期选择”“范围选择”示例）；
  3. Props 说明：名称、类型、默认值、描述（多单词 Props 需明确语义，如 `isRange` 说明“是否为范围选择模式”）；
  4. Events 说明：名称、参数类型、描述；
  5. Slots 说明：名称、描述、默认内容；
  6. 高级示例：复杂场景（如 `DatePicker` 自定义禁用日期、自定义面板样式）；
  7. 注意事项：如兼容性、性能提示。
- 文档工具推荐：`Storybook`（交互式示例）或 `VuePress`（静态文档）。

### 2. 测试规范

- 组件需覆盖 **单元测试** 与 **E2E 测试**：
  - 单元测试：用 `Vitest` 测试组件 Props、Events、方法逻辑（如 `DatePicker` 测试“范围选择时 `modelValue` 为数组”“`disabledDate` 函数生效”）；
  - E2E 测试：用 `Cypress` 测试组件在真实浏览器中的交互（如 `DatePicker` 测试“点击输入框弹出面板”“选择日期后输入框显示正确值”）。
- 测试覆盖率要求：核心组件（如 `Button`、`Input`、`DatePicker`）覆盖率不低于 80%，避免明显逻辑漏洞。

## 六、兼容性与发布规范

### 1. 兼容性要求

- 浏览器支持：兼容 Chrome 90+、Firefox 88+、Safari 14+，不支持 IE11（Vue3 已放弃 IE 支持）；
- SSR 支持：组件需适配 Nuxt3 等 SSR 框架，避免在 `setup` 中直接操作 `window`（可通过 `process.client` 判断环境）；
- 版本兼容：Vue 版本需 ≥ 3.2.0（支持 `script setup` 语法糖）。

### 2. 发布规范

- 版本号遵循 **SemVer 语义化版本**：
  - 主版本号（Major）：不兼容的 API 变更（如 `v2.0.0`）；
  - 次版本号（Minor）：新增功能，兼容旧版本（如 `v1.1.0` 新增 `DatePicker` 范围选择功能）；
  - 修订号（Patch）：bug 修复，兼容旧版本（如 `v1.0.1` 修复 `DatePicker` 日期格式化错误）；
- 发布前需执行：
  1. 单元测试与 E2E 测试，确保无失败用例；
  2. 构建组件库，检查 dist 目录是否完整；
  3. 更新 CHANGELOG.md，记录版本变更内容（多单词组件需明确“新增/修改功能”，如 `v1.1.0: 新增 DatePicker 组件，支持单日期与范围选择`）；
- 发布工具：用 `pnpm publish` 或 `changesets` 管理版本与发布流程。

## 七、总结

Vue3 组件库设计规范的核心是“**一致性、可维护性、用户体验**”，从目录结构、组件实现（尤其是多单词组件的命名与逻辑拆分）、类型定义到文档测试，每一步都需考虑开发者使用便捷性与业务复用性。实际开发中，可根据团队需求调整细节（如是否支持多主题、是否需要 SSR），但需确保规范落地执行，避免组件库后期维护混乱。
