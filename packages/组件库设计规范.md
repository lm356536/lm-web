# Vue3 组件库设计规范

本规范旨在定义 Vue3 组件库的设计、开发、维护标准，确保组件库具备 **一致性、可维护性、可扩展性、良好的开发体验**，同时满足业务复用与生态适配需求（如支持 SSR、主题定制、TypeScript 强类型）。

## 一、核心设计原则

组件库设计需遵循以下 5 大原则，贯穿从需求定义到落地的全流程：

1. **单一职责原则**：一个组件只聚焦一个核心功能（如 `Button` 负责按钮交互，不包含表单验证逻辑），避免过度封装导致臃肿。
2. **一致性原则**：组件的命名、API、交互、样式保持统一（如所有触发“确认”的按钮统一用 `@confirm` 事件，而非 `@ok`/`@submit` 混用）。
3. **可扩展性原则**：预留扩展入口（如插槽、自定义类名、暴露内部方法），支持用户在不修改源码的前提下定制功能。
4. **无侵入性原则**：组件不强制依赖外部环境（如不绑定特定路由库、状态管理库），仅通过 Props/Events 与外部通信。
5. **可访问性原则（A11y）**：符合 W3C 可访问性标准，支持键盘导航、屏幕阅读器，确保不同用户群体（如视障用户）可正常使用。

## 二、目录结构规范

采用 Monorepo 架构（基于 pnpm workspace），目录结构需清晰区分“组件核心代码”“工具层”“文档”“测试”，便于维护与扩展：

```
lm-web/
├── packages/
│   ├── components/       # 组件核心目录（按组件拆分）
│   │   ├── src/
│   │   │   ├── button/   # 单个组件目录（PascalCase 命名）
│   │   │   │   ├── Button.vue       # 组件模板/逻辑
│   │   │   │   ├── button.ts        # Props/Events 类型定义
│   │   │   │   ├── button.css       # 组件样式（或 CSS Modules）
│   │   │   │   └── index.ts         # 组件导出
│   │   │   ├── input/    # 其他组件...
│   │   │   └── index.ts  # 所有组件聚合导出（供外部引入）
│   │   ├── types/        # 全局类型定义（如组件实例类型、通用类型）
│   │   ├── utils/        # 组件共享工具函数（如 DOM 操作、格式转换）
│   │   └── styles/       # 全局样式（主题变量、重置样式、基础工具类）
│   ├── theme/            # 主题包（可选，支持多主题切换）
│   │   ├── src/
│   │   │   ├── variables.css  # 主题变量（颜色、字体、间距等）
│   │   │   └── index.css      # 主题入口
│   └── docs/             # 组件文档（用 VuePress/Storybook 实现）
├── turbo.json            # 构建任务配置（如增量构建、并行任务）
├── vite.config.ts        # 组件库打包配置（Vite 库模式）
└── package.json          # 根目录依赖与脚本
```

## 三、组件实现规范

### 1. 命名规范

#### （1）组件命名

- 采用 **PascalCase 大驼峰命名**（符合 Vue 官方推荐，且与 HTML 标签区分），如 `Button`、`Input`、`Select`。
- 组件目录名与组件名保持一致（如 `Button` 组件放在 `button/` 目录下，避免歧义）。
- 避免与 HTML 原生标签重名（如不命名为 `Div`、`Span`），如需基础容器组件，可加前缀（如 `BaseContainer`）。

#### （2）Props 命名

- 采用 **camelCase 小驼峰命名**（符合 JavaScript 变量规范），如 `isDisabled`、`maxLength`。
- 传递给组件时，模板中可自动转换为 kebab-case（Vue 特性），用户使用时两种格式均可（推荐 kebab-case 更符合 HTML 习惯）：
  ```vue
  <!-- 正确：模板中可用 kebab-case -->
  <MyButton is-disabled />
  <!-- 正确：也可用 camelCase（不推荐，建议统一 kebab-case） -->
  <MyButton isDisabled />
  ```

#### （3）Events 命名

- 采用 **kebab-case 短横线命名**（符合 HTML 事件规范），如 `update:model-value`、`change`、`confirm`。
- 事件名需语义化，避免模糊命名（如不用 `onClick`，而用 `confirm`/`cancel` 明确意图）。
- 支持双向绑定的组件，需遵循 Vue 语法糖 `v-model`，事件名固定为 `update:model-value`：

  ```vue
  <!-- 组件内部触发双向绑定更新 -->
  <script setup>
    const emit = defineEmits(['update:model-value']);
    emit('update:model-value', newValue);
  </script>

  <!-- 用户使用时 -->
  <MyInput v-model="value" />
  ```

#### （4）插槽（Slots）命名

- 默认插槽无需命名，直接用 `<slot>`。
- 具名插槽采用 **kebab-case 命名**，如 `header`、`footer`、`empty`（空状态插槽）。
- 插槽需添加文档说明，明确用途（如 `empty` 插槽用于自定义空数据展示）：

  ```vue
  <!-- 组件内部 -->
  <div class="my-select">
    <slot name="empty">暂无数据</slot>
    <slot></slot> <!-- 默认插槽 -->
  </div>

  <!-- 用户使用时 -->
  <MySelect>
    <template #empty>
      <div>没有匹配的选项</div>
    </template>
  </MySelect>
  ```

### 2. Props 设计规范

#### （1）类型与默认值

- 所有 Props 必须显式声明类型（TypeScript），避免 `any`。
- 必填 Props 需标记 `required: true`，并提供清晰的错误提示（通过 `validator`）。
- 复杂类型（如对象、数组）的默认值需用函数返回（避免引用类型共享）：

  ```typescript
  // button.ts（Props 类型定义）
  export interface ButtonProps {
    // 基础类型 + 默认值
    type?: 'primary' | 'success' | 'default' // 枚举类型，限制可选值
    size?: 'small' | 'medium' | 'large'
    isDisabled?: boolean
    // 复杂类型 + 函数返回默认值
    styles?: Record<string, string>
    // 必填项 + 验证
    text: string // 必填，无默认值
  }

  // Button.vue 中使用
  <script setup lang="ts">
  import { ButtonProps } from './button'
  const props = withDefaults(defineProps<ButtonProps>(), {
    type: 'default',
    size: 'medium',
    isDisabled: false,
    styles: () => ({}) // 复杂类型默认值用函数
  })

  // 可选：添加自定义验证
  const propsWithValidator = defineProps({
    text: {
      type: String,
      required: true,
      validator: (val: string) => {
        if (val.length > 20) {
          console.error('Button 文本长度不能超过 20 个字符')
          return false
        }
        return true
      }
    }
  })
  </script>
  ```

#### （2）Props 精简原则

- 避免冗余 Props：如已支持 `class`/`style` 透传，无需额外定义 `customClass`/`customStyle`（Vue 会自动透传非 Props 属性到根元素）。
- 拆分复杂 Props：如组件需要多个配置项，可将其合并为一个对象类型 Props，避免 Props 数量过多：

  ```typescript
  // 不推荐：Props 数量过多
  interface BadProps {
    labelWidth: string;
    labelAlign: 'left' | 'right';
    inputWidth: string;
  }

  // 推荐：合并为对象类型
  interface GoodProps {
    layout?: {
      labelWidth: string;
      labelAlign: 'left' | 'right';
      inputWidth: string;
    };
  }
  ```

### 3. 样式规范

#### （1）样式隔离

- 优先使用 **Scoped CSS**（通过 `style scoped`）避免样式污染，如需修改子组件样式，可使用 `::v-deep`（Vue3 推荐写法）：

  ```vue
  <style scoped>
    /* 样式隔离：仅作用于当前组件 */
    .my-button {
      padding: 8px 16px;
    }

    /* 修改子组件样式：::v-deep + 子组件选择器 */
    ::v-deep .my-icon {
      margin-right: 4px;
    }
  </style>
  ```

- 复杂组件（如 `Select` 包含下拉面板）可使用 **CSS Modules**（通过 `style module`），避免类名冲突：

  ```vue
  <style module>
    .select {
      position: relative;
    }
    .dropdown {
      position: absolute;
    }
  </style>

  <template>
    <div :class="$style.select">
      <div :class="$style.dropdown"></div>
    </div>
  </template>
  ```

#### （2）主题与 Token 设计

- 采用 **CSS 变量（Custom Properties）** 定义全局主题 Token，确保样式一致性且支持动态切换：

  ```css
  /* styles/variables.css（全局主题变量） */
  :root {
    /* 颜色 Token */
    --color-primary: #42b983;
    --color-success: #52c41a;
    --color-warning: #faad14;
    /* 字体 Token */
    --font-size-sm: 12px;
    --font-size-md: 14px;
    /* 间距 Token */
    --spacing-xs: 4px;
    --spacing-sm: 8px;
  }

  /* 组件样式中使用 Token */
  <style scoped>
  .my-button {
    background: var(--color-primary);
    font-size: var(--font-size-md);
    padding: var(--spacing-sm) var(--spacing-xs);
  }
  </style>
  ```

- 支持主题定制：用户可通过覆盖 CSS 变量修改主题（无需修改组件库源码）：
  ```css
  /* 用户项目中覆盖主题 */
  :root {
    --color-primary: #1890ff; /* 自定义主色为蓝色 */
  }
  ```

#### （3）响应式样式

- 优先使用 **CSS 媒体查询** 实现响应式，避免依赖 JavaScript 监听窗口变化（性能更优）：

  ```css
  .my-container {
    width: 100%;
  }

  @media (min-width: 768px) {
    .my-container {
      width: 750px;
    }
  }

  @media (min-width: 1200px) {
    .my-container {
      width: 1140px;
    }
  }
  ```

- 如需组件内部响应式逻辑（如根据窗口宽度调整行为），使用 Vue3 的 `useWindowSize` 等 Composition API，避免直接操作 `window`。

### 4. 逻辑实现规范

#### （1）Composition API 优先

- 组件逻辑必须使用 **Vue3 Composition API**（`script setup` 语法糖），避免 Options API（不利于逻辑复用与 TypeScript 集成）。
- 复杂逻辑需拆分到独立的 Composable 函数（如 `useInputValue.ts`、`useDropdown.ts`），提高可维护性：

  ```typescript
  // composables/useInputValue.ts（独立逻辑）
  import { ref, watch } from 'vue'

  export function useInputValue(initialValue = '') {
    const value = ref(initialValue)
    const isEmpty = ref(initialValue === '')

    watch(value, (newVal) => {
      isEmpty.value = newVal === ''
    })

    return { value, isEmpty }
  }

  // Input.vue 中使用
  <script setup lang="ts">
  import { useInputValue } from '../../composables/useInputValue'
  const { value, isEmpty } = useInputValue()
  </script>
  ```

#### （2）避免副作用与外部依赖

- 组件内部不直接操作全局状态（如 `window`、`document`），如需操作 DOM，使用 `ref` 或 `useTemplateRefsList`（Vue3 推荐），避免 `document.querySelector`：

  ```vue
  <!-- 正确：使用 ref 操作 DOM -->
  <template>
    <div ref="containerRef"></div>
  </template>

  <script setup lang="ts">
    import { ref, onMounted } from 'vue';
    const containerRef = ref<HTMLDivElement>(null);

    onMounted(() => {
      if (containerRef.value) {
        containerRef.value.style.height = '200px';
      }
    });
  </script>
  ```

- 不依赖外部库（如 `lodash`），如需工具函数，内置到组件库的 `utils` 目录（避免增加用户依赖体积）。

#### （3）性能优化

- 避免在 `setup` 或模板中执行 heavy 计算，使用 `computed` 缓存计算结果：

  ```vue
  <script setup lang="ts">
    import { ref, computed } from 'vue';
    const list = ref([1, 2, 3, 4, 5]);

    // 推荐：computed 缓存过滤结果
    const filteredList = computed(() => {
      return list.value.filter(item => item > 2);
    });

    // 不推荐：每次渲染都会重新计算
    const badFilteredList = () => {
      return list.value.filter(item => item > 2);
    };
  </script>
  ```

- 大型列表组件（如 `Table`、`Select`）需支持虚拟滚动（如集成 `vue-virtual-scroller`），避免渲染过多 DOM 导致性能问题。
- 使用 `shallowRef`/`markRaw` 处理不需要响应式的数据（如大型配置对象、第三方库实例），减少 Vue 响应式追踪开销：

  ```typescript
  import { shallowRef, markRaw } from 'vue';
  import { SomeHeavyLibrary } from 'some-library';

  // 不需要响应式的第三方实例，用 markRaw 标记
  const heavyInstance = markRaw(new SomeHeavyLibrary());
  // 仅需追踪顶层引用的对象，用 shallowRef
  const config = shallowRef({
    a: 1,
    b: { c: 2 }, // 内部属性变化不追踪
  });
  ```

## 四、TypeScript 规范

### 1. 类型定义

- 组件 Props、Events、Slots、暴露方法需显式定义类型，放在组件目录下的 `xxx.ts` 文件（如 `button.ts`），便于复用与维护。
- 全局通用类型（如 `SizeType`、`ValueType`）放在 `packages/components/types/` 目录，统一导出：

  ```typescript
  // types/index.ts（全局通用类型）
  export type SizeType = 'small' | 'medium' | 'large';
  export type StatusType = 'success' | 'warning' | 'error' | 'info';

  // button.ts（组件类型）
  import { SizeType, StatusType } from '../../types';
  export interface ButtonProps {
    size?: SizeType;
    status?: StatusType;
    isDisabled?: boolean;
  }

  // 暴露组件实例类型（供用户通过 ref 获取）
  export interface ButtonInstance {
    focus: () => void; // 组件暴露的方法
  }
  ```

### 2. 类型导出

- 组件库需生成 **类型声明文件（.d.ts）**，确保用户在使用时能获得完整的类型提示。
- 通过 Vite 配置自动生成类型声明（需安装 `vue-tsc`）：

  ```typescript
  // vite.config.ts
  import { defineConfig } from 'vite';
  import vue from '@vitejs/plugin-vue';
  import vueJsx from '@vitejs/plugin-vue-jsx';

  export default defineConfig({
    plugins: [vue(), vueJsx()],
    build: {
      lib: {
        entry: 'packages/components/src/index.ts',
        name: 'MyComponentLibrary',
        fileName: format => `my-component-library.${format}.js`,
      },
      rollupOptions: {
        external: ['vue'],
        output: {
          globals: { vue: 'Vue' },
        },
      },
    },
    // 生成类型声明
    plugins: [
      // 其他插件...
      {
        name: 'generate-dts',
        async closeBundle() {
          const { execSync } = require('child_process');
          execSync('vue-tsc --declaration --emitDeclarationOnly --outDir dist/types', {
            stdio: 'inherit',
          });
        },
      },
    ],
  });
  ```

## 五、文档与测试规范

### 1. 文档规范

- 每个组件需包含 **完整文档**，内容包括：
  1. 组件介绍：核心功能与使用场景；
  2. 基础示例：最简单的使用代码；
  3. Props 说明：名称、类型、默认值、描述；
  4. Events 说明：名称、参数类型、描述；
  5. Slots 说明：名称、描述、默认内容；
  6. 高级示例：复杂场景（如自定义主题、事件监听）；
  7. 注意事项：如兼容性、性能提示。
- 文档工具推荐：`Storybook`（交互式示例）或 `VuePress`（静态文档）。

### 2. 测试规范

- 组件需覆盖 **单元测试** 与 **E2E 测试**：
  - 单元测试：用 `Vitest` 测试组件 Props、Events、方法逻辑（如按钮点击触发 `confirm` 事件）；
  - E2E 测试：用 `Cypress` 测试组件在真实浏览器中的交互（如输入框输入内容后，按钮状态变化）。
- 测试覆盖率要求：核心组件（如 `Button`、`Input`）覆盖率不低于 80%，避免明显逻辑漏洞。

## 六、兼容性与发布规范

### 1. 兼容性要求

- 浏览器支持：兼容 Chrome 90+、Firefox 88+、Safari 14+，不支持 IE11（Vue3 已放弃 IE 支持）；
- SSR 支持：组件需适配 Nuxt3 等 SSR 框架，避免在 `setup` 中直接操作 `window`（可通过 `process.client` 判断环境）；
- 版本兼容：Vue 版本需 ≥ 3.2.0（支持 `script setup` 语法糖）。

### 2. 发布规范

- 版本号遵循 **SemVer 语义化版本**：
  - 主版本号（Major）：不兼容的 API 变更（如 `v2.0.0`）；
  - 次版本号（Minor）：新增功能，兼容旧版本（如 `v1.1.0`）；
  - 修订号（Patch）：bug 修复，兼容旧版本（如 `v1.0.1`）；
- 发布前需执行：
  1. 单元测试与 E2E 测试，确保无失败用例；
  2. 构建组件库，检查 dist 目录是否完整；
  3. 更新 CHANGELOG.md，记录版本变更内容；
- 发布工具：用 `pnpm publish` 或 `changesets` 管理版本与发布流程。

## 七、总结

Vue3 组件库设计规范的核心是“**一致性、可维护性、用户体验**”，从目录结构、组件实现、类型定义到文档测试，每一步都需考虑开发者使用便捷性与业务复用性。实际开发中，可根据团队需求调整细节（如是否支持多主题、是否需要 SSR），但需确保规范落地执行，避免组件库后期维护混乱。
